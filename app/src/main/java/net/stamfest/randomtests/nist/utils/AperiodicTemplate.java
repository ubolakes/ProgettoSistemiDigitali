/* 
 * (c) 2016 by Peter Stamfest <peter@stamfest.at>
 * (c) 1999 by the National Institute Of Standards & Technology
 * 
 * This is copyrighted code.  All rights reserved.
 * Please see the file license.txt for details.
 */
package net.stamfest.randomtests.nist.utils;

import java.util.Iterator;

/**
 * An aperiodic template generator that actually works (the code in the NIST
 * paper does NOT work.
 *
 * How an aperiodic template is defined is never spelled out in the NIST paper,
 * but when looking hard at the provided template files it becomes obvious that
 * an aperiodic template is a bit pattern that does not have a common head and
 * tail of any length up to half the template length.
 *
 * This class has been checked to produce data identical for all bit lengths
 * from 2 to 21 as distributed with the original NIST code.
 *
 * @author Peter Stamfest
 */
public class AperiodicTemplate implements Iterable<Long> {

    public static void main(String argv[]) {
        int m = 6;
        if (argv.length == 1) {
            m = Integer.parseInt(argv[0]);
        }
        AperiodicTemplate at = new AperiodicTemplate(m);

        long num = ((long) 1) << m;
        int nonPeriodic = 0;
        for (Long i : at) {
            nonPeriodic++;
            System.out.println(at.bitstring(i, " "));
        }
    }

    private long[] left, right;
    private int len;
    private int[] shift;
    private final static int numOfTemplates[] = new int[32];

    /* { 0, 0, 2, 4, 6, 12, 20, 40, 74, 148, 284, 568, 1116,
                                                           2232, 4424, 8848, 17622, 35244, 70340, 140680, 281076, 562152,
    1123736, 2247472, 4493828, 8987656, }; */


    static {
        // these are actually never used. So assigning 0 is only for aestethic reasons...
        numOfTemplates[0] = numOfTemplates[1] = 0;

        /* There are only 2 templates for a length of two bits:
          0 1
          1 0
         */
        numOfTemplates[2] = 2;

        for (int i = 3; i < numOfTemplates.length; i++) {
            if ((i % 2) == 1) {
                /*
                 * Templates with an odd number of bits can be generated by
                 * splitting the templates of the next smaller length in two
                 * even length halfs and inserting either 0 or 1 in between.
                 * This means there are twice as many templates for an odd
                 * length template than for the next smaller even length one.
                 */
                numOfTemplates[i] = 2 * numOfTemplates[i - 1];
            } else {
                /*
                  Templates with an even lengths can be generated from templates with the next lower length by 
                  
                (a) adding the inverted first bit of the smaller templates to the end of the new templates. This yields new templates, because all shorter templates ALREADY have different first and last bits.
                  
                 */
                numOfTemplates[i] = 2 * numOfTemplates[i - 1] - numOfTemplates[i / 2];
            }
        }
    }

    public AperiodicTemplate(int len) {
        if (len < 2 || len > 31) {
            throw new IllegalArgumentException("len must be in the range [2,31]");
        }

        this.len = len;

        int half = len / 2;
        left = new long[half];
        right = new long[half];
        shift = new int[half];

        long l = -1, r = 1;
        l <<= len - 1;

        /**
         * pre-calculate bit masks for start and end bits that must be checked
         * against each other. shift[i] holds the number of bits
         */
        for (int i = 0; i < half; i++) {
            left[i] = l;
            right[i] = r;
            shift[i] = len - 1 - i;

            l >>= 1;
            r = (r << 1) | 1;
        }
    }

    public int getCount() {
        return numOfTemplates[len];
    }

    public long checkValue(long value) {
        for (int i = 0; i < left.length; i++) {
//             if (((value & left[i]) >> shift[i]) == (value & right[i])) return 0;
            if (((value >> shift[i]) & right[i]) == (value & right[i])) {
                return 0;
            }
        }
        return value;
    }

    public String bitstring(long value, String delimiter) {
        StringBuilder sb = new StringBuilder();
        long mask = 1 << (len - 1);
        for (int i = 0; i < len; i++) {
            if (i > 0 && delimiter != null) {
                sb.append(delimiter);
            }
            sb.append((value & mask) != 0 ? '1' : '0');
            mask >>= 1;
        }

        return sb.toString();
    }

    @Override
    public Iterator<Long> iterator() {
        return new Iterator<Long>() {
            long n = 0;
            long max = (1 << len) - 2;

            @Override
            public boolean hasNext() {
                return n < max;
            }

            @Override
            public Long next() {
                while (n++ < max) {
                    if (checkValue(n) > 0) {
                        return n;
                    }
                }
                return 0L;
            }
        };
    }
}
